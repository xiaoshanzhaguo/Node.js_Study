/*
    Buffer（缓冲区）
        - Buffer的结构和数组很像，操作的方法也和数组相似
        - 数组中不能存储二级制的文件，而Buffer就是专门用来存储二进制数据
        - 使用buffer不需要引入模块，直接使用即可
        - 在buffer中，存储的都是二进制数据，但是显示时都是以16进制的形式显示
        （虽然下面输出的是48等值，这里是16进制，计算机里所有二进制的数据都会以十六进制的形式显示 因为二进制太长了）
            buffer中每一个元素的范围是从00 - ff  0-255
            00000000 - 11111111
            (在计算机的内存中，把它想象成一个个小格子，内存里的每一个小格，只能保存两个东西，要么存0，要么存1；
            因此，内容里的结构，要么是0，要么是1 一个格叫一位)

            在计算机中，一个0 或一个1 我们称为1位(bit)

            8bit = 1byte(字节)  字节是我们数据传输的时的最小的单位
            1024byte = 1kb
            1024kb = 1mb
            1024mb = 1gb
            1024gb = 1tb

            buffer中的一个元素，占用内存中的一个字节

          - Buffer的大小，一旦确定，则不能修改，Buffer实际上是对底层内存的直接操作
          (由于是创建的连续的空间来存储数据，因此如果再添加其他的数据，空间就不连续了，可能有些是被其他的程序占用了，
          比如下面的例子中，新加的元素被放到不连续的空间里，会导致同样一个数组里，一个buffer里，一个缓冲区的元素，可能这放一个，那放一个，很杂乱。
          这样就不好维护，性能会比较差)
 */

// var str = "Hello Atguigu";
var str = "Hello 尚硅谷";

//将一个字符串保存到buffer中
var buf = Buffer.from(str);
//将字符串转化为二进制保存，为什么要转化为二进制？因为数据最后要发送给我们的客户端，或者说是从客户端接收过来的数据，
//在传输的过程中，都是以二进制的形式传输，因为我们在传输的时候，传输的是电信号010101

console.log(buf);
//这里打印的值是13，说明buf在内存中占用13个字节
console.log(buf.length);  //占用内存的大小
console.log(str.length);  //字符串的长度
//上面这两个内容并不一样，因为我们这里恰巧用的是英文，英文正好每个字母就占一个字节 而一个汉字占用三个字节

//创建一个指定大小的buffer
//buffer的所有构造函数都是不推荐使用的
var buf2 = new Buffer(10); //10个字节的buffer
console.log(buf2.length);

//创建一个10个字节的buffer 这里直接用构造函数对象去调用alloc函数
var buf2 = Buffer.alloc(10); //alloc是分配的意思，这里就是在内存中分配出10个字节的空间来放这个buffer
//通过索引，类操作buffer中的元素
buf2[0] = 88;  //这里添进去的是十进制，输出的是十六进制58
buf2[1] = 255;
buf2[2] = 0xaa; //这里也可以添加16进制的数，16进制以0x开头
buf2[3] = 256; //这里输出的是00
buf2[3] = 556; //这里输出的是2c 通过下面的模拟，发现它只取了后8位
// buf2[10] = 15;  //当前我们的buffer长度是10，这里超出了范围，以 以前数组array的话，会自动给我们加一个；我们这个数组呢？
console.log(buf2);

//只要数字在控制台或在页面中输出一定是10进制 因此下面输出的是10进制170
//如果不控制 控制台只输出10进制，那我们没有办法确定输出的 11 到底是什么？ 有可能是2、10、16进制
//如果我们想输出16进制，只要它是数字，就永远做不到，但是不是数字就可以考虑考虑
//因此，如果真的需要实现上面的需求，就调用toString()方法
console.log(buf2[2]);
console.log(buf2[2].toString(16));  //把他转换成16进制的字符串
console.log(buf2[2].toString(2));  //把他转换成2进制的字符串

//1000101100  556
//  00101100 2c


for (var i = 0; i < buf2.length; i++) {
    console.log(buf2[i]);
}

//Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是buffer中可能含有敏感数据
// var buf3 = Buffer.alloc(10);  //这里创建的，全都是00
var buf3 = Buffer.allocUnsafe(10);  //而这里创建的是有值的（老师那里是有，但是我这里输出的还是00）
console.log(buf3);
//buffer是直接对内存进行操作的，内存是反复去使用的。对于alloc来说，它创建了10个字节的数据，它会将里面的内容全部清空（在分配空间时，直接把数据给清了）
//而allocUnsafe 在分配空间时，没有将里面的数据清空，而别人用过的内存，数据还在里面存储着，在分配内存时把数据一块拿了过来。
//假如这块内存刚好保存的是用户的个人信息，那就这样被我们取过来了，可能有安全隐患的
//为什么要用这个呢？因为这个性能好点，它只作了分配空间，但是为了避免信息的泄露，我们还是用alloc比较多

/*
    总结
    Buffer.from(str) 将一个字符串转换为buffer
    Buffer.alloc(size) 创建一个指定大小的Buffer
    Buffer.alloUnsafe(size) 创建一个指定大小的Buffer，但是可能包含敏感数据
    buf.toString() 将缓冲区中的数据转换为字符串
 */

var buf4 = Buffer.from("我是一段文本数据");
// console.log(buf4);
console.log(buf4.toString()); //这里将缓冲区里的数据转换为字符串

/*
    Buffer为什么叫缓冲区呢？ Nodejs作为服务器，无非是两件事，一是接受用户发过来的请求，二是给数据返回响应
    请求全都是二进制数据，在我们接收用户发的请求时，面临一个问题，用户发的数据存哪里？存到Buffer里，因此叫做缓冲区。
    意味着当我们读取数据之前，要用Buffer把这些数据保存起来
    同样，当我们把数据发送给用户时，也要把数据转换为二进制，在发送之前，数据也会保存到Buffer里。因此叫做缓冲区。
    类方法，通过Buffer的构造函数去调用
    而后面还讲了一些方法，是用Buffer对象去调用的 比如 buf[index]等
 */