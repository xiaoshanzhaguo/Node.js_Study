/**
 *  同步、异步、简单文件的写入不适合大文件的写入，性能较差，容易导致内存溢出
 */
var fs = require("fs");

//流式文件写入
//第一步要先找到水管
//创建一个可写流 因为我们是要向文件里写入内容的。 看文档找方法
/**
 *   fs.createWriteStream(path[, options])
 *      - 可以用来创建一个可写流
 *      - path 文件路径
 *      - options 配置的参数 （一般可以不写）
 */
var ws = fs.createWriteStream("hello3.txt"); //这里意味着水管已经插进去了

//这里有一个问题，水管接上了，没有关，这样如果在服务器里，会对性能造成影响。
//在关闭流之前，还要说一个问题。现在的流一般情况下需要一个事情，需要知道流的打开和关闭
//怎么监听流的打开和关闭呢？

//可以通过监听流的open和close事件来监听流的打开和关闭 如果你不关心它停没停，也可以不监听的
//要给ws绑定一个open事件 当open事件发生时，函数被触发
/**
 *  on(事件字符串，回调函数)
 *      - 可以为对象绑定一个事件
 *
 *  once(事件字符串，回调函数)
 *      - 可以为对象绑定一个一次性的事件，该事件会在触发一次以后自动失效
 */
ws.once("open", function () {
    console.log("流打开了~~~");
    //流只打开一次，但是用on绑定事件会带来一个问题，open事件只触发了一次，即使事件触发完了，函数依然在。
    //但是其实函数已经没有用了，open事件是一个一次性的事件，没必要用on，用once，
    //on绑定的是一个长期有效的事件，而once是绑定一次性的事件。运行效果是一样的。但是once的性能会好一些。
})

ws.once("close", function () {
    console.log("流关闭了~~~"); //这里没有输出，并没有触发close这个事件
})

//通过ws向文件中输出内容
//特点：是不是只能写一次？不是，只要文件流还在，可以一直写下去 可以分多次写入  比较适合大型文件
ws.write("通过可写流写入文件的内容");
ws.write("今天天气真不错");
ws.write("锄禾日当午");
ws.write("红掌拨清波");
ws.write("通过xxxx写入的内容");
ws.write("通过可写流写入文件的内容");

//关闭流
// ws.close();
ws.end();

